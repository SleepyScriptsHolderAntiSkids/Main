--// Structure taken from https://github.com/shlexware/Sirius/blob/request/library/sense/source.lua (they have like the most optimized structure) | Elements have been rewritten by dementia enjoyer, ignore awful code; thanks --\\

-- Services
local run_service = game:GetService("RunService");
local players = game:GetService("Players");
local workspace = game:GetService("Workspace");

-- Variables
local local_player = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local params = RaycastParams.new(); do
	params.FilterType = Enum.RaycastFilterType.Blacklist;
	params.FilterDescendantsInstances = {camera};
end

-- Locals
local floor = math.floor;
local vector2_new = Vector2.new;
local round = math.round;
local clear = table.clear;
local find = table.find;

-- Methods
local find_first_child = workspace.FindFirstChild;
local find_first_child_of_class = workspace.FindFirstChildOfClass;
local lerp_color = Color3.new().Lerp;
local lerp2 = Vector2.zero.Lerp;

-- Constants
local CORNER_BOXES_BOTTOM_OFFSET = vector2_new(0, 1);
local HEALTH_BAR_OFFSET = vector2_new(4, 0);
local HEALTH_BAR_OUTLINE_OFFSET = vector2_new(0, 1);

-- Functions
local function world_to_screen(world)
	local screen, on_screen = camera.WorldToViewportPoint(camera, world);
	return vector2_new(screen.X, screen.Y), on_screen, screen.Z;
end

-- ESP Object
local esp_object = {};
esp_object.__index = esp_object;

function esp_object.new(player, interface)
	local self = setmetatable({}, esp_object);
	self.player = assert(player, "Missing argument #1 (Player expected)");
	self.interface = assert(interface, "Missing argument #2 (table expected)");
	self:Construct();
	return self;
end

function esp_object:_create(class, properties)
	local drawing = Drawing.new(class);

	for property, value in properties do
		pcall(function()
			drawing[property] = value;
		end)
	end

	self.bin[#self.bin + 1] = drawing;
	return drawing;
end

function esp_object:Construct()
	self.char_cache = {};
	self.child_count = 0;
	self.bin = {};
	self.drawings = {
		visible = {
			box_corners = {
				top_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		top_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		top_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		top_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		bottom_left_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		bottom_left_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
				
        		bottom_right_vertical_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),
        		bottom_right_horizontal_outline = self:_create("Line", { Thickness = 3, Visible = false, Color = Color3.fromRGB(0, 0, 0) }),

				top_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		top_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		top_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		top_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		bottom_left_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		bottom_left_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
				
        		bottom_right_vertical = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
        		bottom_right_horizontal = self:_create("Line", { Thickness = 1, Visible = false, Color = Color3.fromRGB(255, 255, 255) }),
			},

			box_outline = self:_create("Square", { Thickness = 3, Visible = false}),
			box = self:_create("Square", { Thickness = 1, Visible = false}),

			healthbar_outline = self:_create("Line", { Thickness = 3, Visible = false}),
			health_bar = self:_create("Line", { Thickness = 1.5, Visible = false}),

			health_visual_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
			name_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
			weapon_text = self:_create("Text", { Text = "", Font = 2, Size = 13, Center = true, Outline = true, OutlineColor = Color3.fromRGB(0, 0, 0), Visible = false }),
		},
	};

	self.render_connection = run_service.Heartbeat:Connect(function()
		self:Update();
		self:Render();
	end)
end

function esp_object:Destruct()
	self.render_connection:Disconnect();

	for i = 1, #self.bin do
		self.bin[i]:Remove();
	end

	clear(self);
end

function esp_object:Update()
	local interface = self.interface;
	local player = self.player;
	local character = interface.get_character(player);

	params.FilterDescendantsInstances = interface.get_ignorelist();
	self.options = interface.team_settings[interface.is_friendly(player) and "friendly" or "enemy"];
	self.character = character;
	self.health, self.max_health = interface.get_health(player);
	self.weapon = interface.get_weapon(player);
	self.name = player.Name;
	self.enabled = self.options.enabled and character and not (#interface.whitelist > 0 and not find(interface.whitelist, player.UserId));

	local head = self.enabled and find_first_child(character, "Head");
	local humanoid_root_part = self.enabled and find_first_child(character, "HumanoidRootPart");

	if (not head) or (not humanoid_root_part) then
		self.char_cache = {};
		self.on_screen = false;
		return;
	end

	local root_position = humanoid_root_part.Position - Vector3.new(0, 0.35, 0);
	local screen_position, on_screen, depth = world_to_screen(root_position);

	self.on_screen = on_screen;
	self.distance = depth;

	if (interface.shared_settings.limit_distance and depth > interface.shared_settings.max_distance) then
		self.on_screen = false;
	end

	if (self.on_screen) then
        local scale = (humanoid_root_part.Size.Y * camera.ViewportSize.Y) / ((2 * depth * math.tan(math.rad(camera.FieldOfView) / 2)) * 1.5);
        
		local height = 4 * scale;
        local width = 2.5 * scale;
	
		local top_left = vector2_new(round(screen_position.X - (width / 2)), round(screen_position.Y - (height / 2)));
		local bottom_right = vector2_new(round(screen_position.X + (width / 2)), round(screen_position.Y + (height / 2)));
	
		self.corners = {
			top_left = top_left,
			bottom_right = bottom_right,
			bottom_left = vector2_new(top_left.X, bottom_right.Y),
			top_right = vector2_new(bottom_right.X, top_left.Y)
		};
	end
end

function esp_object:Render()
	local corners = self.corners;
	
	if (corners) then
		local on_screen = self.on_screen or false;
		local enabled = self.enabled or false;
		local visible = self.drawings.visible;
		local options = self.options;

		local vis = (enabled and on_screen and options.box);
		local pos = corners.top_left;
		local size = corners.bottom_right - pos;

		-- Boxes
		do
			local box_type = options.box_type or "box";

			-- Box
			do
				visible.box.Visible = vis and options.box_type == "box";
				visible.box_outline.Visible = visible.box.Visible;

				if (box_type == "box" and visible.box.Visible) then
					local box = visible.box;
					box.Position = pos;
					box.Size = size;
					box.Color = options.box_color;
					box.Transparency = 1;

					local box_outline = visible.box_outline;
					box_outline.Position = box.Position;
					box_outline.Size = box.Size;
					box_outline.Color = Color3.fromRGB(0, 0, 0);
					box_outline.Transparency = 1;
				end
			end

			-- Corner
			do -- This is soooo bad help !!
				local box_corners = visible.box_corners;

				for index, object in box_corners do
					if (not string.find(index, "outline")) then
						object.Color = options.box_color;
					end

					object.Visible = vis and options.box_type == "corner";
				end
			
				if (box_type == "corner" and vis) then
					local position = pos + size / 2;
					local width = size.X / 2;
					local height = size.Y / 2;
				
					local corner_length = math.clamp(1 / self.distance * 750, 1, 300);

					local top_left_position = vector2_new(floor(position.X - width), floor(position.Y - height));
					local top_right_position = vector2_new(floor(position.X + width), floor(position.Y - height ));
					local bottom_left_position = vector2_new(floor(position.X - width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
					local bottom_right_position = vector2_new(floor(position.X + width), floor(position.Y + height)) - CORNER_BOXES_BOTTOM_OFFSET;
				
					-- Elements
					local top_left_vertical = box_corners.top_left_vertical;
					top_left_vertical.From = top_left_position;
					top_left_vertical.To = vector2_new(top_left_position.X, top_left_position.Y + corner_length);

					local top_left_horizontal = box_corners.top_left_horizontal;
					top_left_horizontal.From = top_left_position;
					top_left_horizontal.To = vector2_new(top_left_position.X + corner_length, top_left_position.Y);

					local top_right_vertical = box_corners.top_right_vertical;
					top_right_vertical.From = top_right_position;
					top_right_vertical.To = vector2_new(top_right_position.X, top_right_position.Y + corner_length);

					local top_right_horizontal = box_corners.top_right_horizontal;
					top_right_horizontal.From = top_right_position;
					top_right_horizontal.To = vector2_new(top_right_position.X - corner_length, top_right_position.Y);

					local bottom_left_vertical = box_corners.bottom_left_vertical;
					bottom_left_vertical.From = bottom_left_position;
					bottom_left_vertical.To = vector2_new(bottom_left_position.X, bottom_left_position.Y - corner_length);

					local bottom_left_horizontal = box_corners.bottom_left_horizontal;
					bottom_left_horizontal.From = bottom_left_position;
					bottom_left_horizontal.To = vector2_new(bottom_left_position.X + corner_length, bottom_left_position.Y)

					local bottom_right_vertical = box_corners.bottom_right_vertical;
					bottom_right_vertical.From = vector2_new(bottom_right_position.X, bottom_right_position.Y + 1);
					bottom_right_vertical.To = vector2_new(bottom_right_position.X, bottom_right_position.Y - corner_length);

					local bottom_right_horizontal = box_corners.bottom_right_horizontal;
					bottom_right_horizontal.From = bottom_right_position;
					bottom_right_horizontal.To = vector2_new(bottom_right_position.X - corner_length, bottom_right_position.Y);
				
					-- Outline
					do
						local top_right_vertical_outline = box_corners.top_right_vertical_outline;
						top_right_vertical_outline.From = vector2_new(top_right_vertical.From.X, top_right_vertical.From.Y - 1.2);
						top_right_vertical_outline.To = vector2_new(top_right_vertical.To.X, top_right_vertical.To.Y + 1);

						local bottom_right_horizontal_outline = box_corners.bottom_right_horizontal_outline;
						bottom_right_horizontal_outline.From = vector2_new(bottom_right_horizontal.From.X + 1.2, bottom_right_horizontal.From.Y);
						bottom_right_horizontal_outline.To = vector2_new(bottom_right_horizontal.To.X - 1, bottom_right_horizontal.To.Y);

						local bottom_right_vertical_outline = box_corners.bottom_right_vertical_outline;
						bottom_right_vertical_outline.From = vector2_new(bottom_right_vertical.From.X, bottom_right_vertical.From.Y);
						bottom_right_vertical_outline.To = vector2_new(bottom_right_vertical.To.X, bottom_right_vertical.To.Y - 1);

						local top_right_horizontal_outline = box_corners.top_right_horizontal_outline;
						top_right_horizontal_outline.From = vector2_new(top_right_horizontal.From.X, top_right_horizontal.From.Y)
						top_right_horizontal_outline.To = vector2_new(top_right_horizontal.To.X - 1, top_right_horizontal.To.Y);

						local top_left_horizontal_outline = box_corners.top_left_horizontal_outline;
						top_left_horizontal_outline.From = vector2_new(top_left_horizontal.From.X - 1, top_left_horizontal.From.Y);
						top_left_horizontal_outline.To = vector2_new(top_left_horizontal.To.X + 1, top_left_horizontal.To.Y);

						local top_left_vertical_outline = box_corners.top_left_vertical_outline;
						top_left_vertical_outline.From = vector2_new(top_left_vertical.From.X, top_left_vertical.From.Y);
						top_left_vertical_outline.To = vector2_new(top_left_vertical.To.X, top_left_vertical.To.Y + 1);

						local bottom_left_horizontal_outline = box_corners.bottom_left_horizontal_outline;
						bottom_left_horizontal_outline.From = vector2_new(bottom_left_horizontal.From.X - 1, bottom_left_horizontal.From.Y);
						bottom_left_horizontal_outline.To = vector2_new(bottom_left_horizontal.To.X + 1, bottom_left_horizontal.To.Y);

						local bottom_left_vertical_outline = box_corners.bottom_left_vertical_outline;
						bottom_left_vertical_outline.From = vector2_new(bottom_left_vertical.From.X, bottom_left_vertical.From.Y);
						bottom_left_vertical_outline.To = vector2_new(bottom_left_vertical.To.X, bottom_left_vertical.To.Y - 1);
					end
				end
			end
	    end

	    -- Healthbar
		do
			local health_bar = visible.health_bar;

	        health_bar.Visible = (enabled and on_screen) and options.health_bar;
		    visible.healthbar_outline.Visible = health_bar.Visible;

		    if (health_bar.Visible) then
				local bar_from = corners.top_left - HEALTH_BAR_OFFSET
				local bar_to = corners.bottom_left - HEALTH_BAR_OFFSET
			
				health_bar.To = bar_to
				health_bar.From = lerp2(bar_to, bar_from, self.health / self.max_health)
				health_bar.Color = (options.dynamic_color and lerp_color(options.dying_color, options.healthy_color, self.health / self.max_health)) or options.health_bar_color
			
				local healthbar_outline = visible.healthbar_outline
				healthbar_outline.To = bar_to + HEALTH_BAR_OUTLINE_OFFSET
				healthbar_outline.From = bar_from - HEALTH_BAR_OUTLINE_OFFSET
				healthbar_outline.Color = Color3.fromRGB(0, 0, 0)
			end

			-- Health Text
			do
				local health_text = visible.health_visual_text;
				health_text.Visible = (enabled and on_screen) and options.health_text and health_bar.Visible;

				if (health_text.Visible) then
					health_text.Text = tostring(floor(self.health));
					health_text.Color = options.health_text_color;

					health_text.Position = health_bar.From + Vector2.new(-13, -3);
				end
			end
		end

		-- Name
		do
			local name = visible.name_text;
			name.Visible = (enabled and on_screen) and options.name_text;

			if (name.Visible) then
				name.Text = self.name;
				name.Color = options.name_text_color;
				name.Position = Vector2.new(pos.X + (size.X / 2), pos.Y - 15) - Vector2.new(0, 2);
			end
		end

		-- Weapon
		do
			local weapon = visible.weapon_text;
			weapon.Visible = (enabled and on_screen) and options.weapon_text;

			if (weapon.Visible) then
				weapon.Text = self.weapon;
				weapon.Color = options.weapon_text_color;
				weapon.Position = Vector2.new(pos.X + (size.X / 2), pos.Y + size.Y) + Vector2.new(0, 2);
			end
		end
	end
end

-- interface
local esp = {
	loaded = false,
	object_cache = {},
	whitelist = {},
	shared_settings = {
		limit_distance = true,
		max_distance = 300,
	},
	team_settings = {
		enemy = {
			enabled = false,

			box = false,
			box_type = "box", -- corner & box

			weapon_text = false,
			health_text = false,
			name_text = false,

			health_bar = false,
			dynamic_color = false,

			box_color = Color3.fromRGB(255, 255, 255),
			weapon_text_color = Color3.fromRGB(255, 255, 255),
			name_text_color = Color3.fromRGB(255, 255, 255),

			health_text_color = Color3.fromRGB(255, 255, 255),
			health_bar_color = Color3.fromRGB(255, 255, 255),

			dying_color = Color3.fromRGB(255, 0, 0),
			healthy_color = Color3.fromRGB(0, 255, 0),
		},
		friendly = {
			enabled = false,

			box = false,
			box_type = "box", -- corner & box

			weapon_text = false,
			health_text = false,
			name_text = false,

			health_bar = false,
			dynamic_color = false,

			box_color = Color3.fromRGB(255, 255, 255),
			weapon_text_color = Color3.fromRGB(255, 255, 255),
			name_text_color = Color3.fromRGB(255, 255, 255),

			health_text_color = Color3.fromRGB(255, 255, 255),
			health_bar_color = Color3.fromRGB(255, 255, 255),

			dying_color = Color3.fromRGB(255, 0, 0),
			healthy_color = Color3.fromRGB(0, 255, 0),
		},
	}
};

function esp.Load()
	local function create_object(player)
		esp.object_cache[player] = {
			esp_object.new(player, esp),
		};
	end

	local function remove_object(player)
		local object = esp.object_cache[player];
		if object then
			for i = 1, #object do
				object[i]:Destruct();
			end

			esp.object_cache[player] = nil;
		end
	end

	local plrs = players:GetPlayers();
    
	for i = 2, #plrs do
		create_object(plrs[i]);
	end

	esp.playerAdded = players.PlayerAdded:Connect(create_object);
	esp.playerRemoving = players.PlayerRemoving:Connect(remove_object);
	esp.loaded = true;
end

function esp.Unload()
	for index, object in esp.object_cache do
		for i = 1, #object do
			object[i]:Destruct();
		end

		esp.object_cache[index] = nil;
	end

	esp.playerAdded:Disconnect();
	esp.playerRemoving:Disconnect();
	esp.loaded = false;
end

-- game specific functions
function esp.get_ignorelist()
	return {local_player.Character, camera};
end

function esp.get_weapon(player)
	local character = player and esp.get_character(player);

	if (not character) then
		return "Unequipped";
	end

	local tool = find_first_child_of_class(character, "Tool");

	if (not tool) then
		return "Unequipped";
	end

	return tool.Name;
end

function esp.is_friendly(player)
	return player.Team and player.Team == local_player.Team;
end

function esp.get_character(player)
	return player.Character;
end

function esp.get_health(player)
	local character = player and esp.get_character(player);
	local humanoid = character and find_first_child_of_class(character, "Humanoid");

	if (humanoid) then
		return humanoid.Health, humanoid.MaxHealth;
	end

	return 100, 100;
end

return esp;
--esp.Load();
