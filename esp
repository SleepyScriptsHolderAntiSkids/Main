local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        for _, method in {"remove", "Disconnect"} do
            pcall(function() value[method](value) end)
        end
    end
    return self[index]
end

local declare = global.declare
local services = declare(global, "services", {})
declare(services, "loop", { cache = {} })
declare(services, "new", {})
declare(services, "player", { cache = {} })

function services.loop:new(index, func, disabled)
    local cache = self.cache
    local entry = cache[index]

    if not entry then
        entry = {
            enabled = not disabled,
            func = func,
            toggle = function(self, state)
                self.enabled = (state == nil) and not self.enabled or state
            end,
            remove = function() cache[index] = nil end
        }
        cache[index] = entry
    else
        entry.enabled = not disabled
        entry.func = func
    end

    if entry.enabled then
        task.defer(function() if entry.func then entry.func() end end)
    end
    return entry
end

services.loop.connection = cloneref(game:GetService("RunService")).RenderStepped:Connect(function(dt)
    for _, entry in pairs(services.loop.cache) do
        if entry.enabled then
            pcall(entry.func, dt)
        end
    end
end)

function services.new.drawing(class, props)
    local draw = Drawing.new(class)
    for k, v in pairs(props) do
        pcall(function() draw[k] = v end)
    end
    return draw
end

-- Player Handling
local playerService = services.player
function playerService:check(character)
    local ok, valid = pcall(function()
        return character and character.Parent and character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")
    end)
    return ok and valid
end

function playerService:find(player)
    for char, data in pairs(self.cache) do
        if data.player == player then return char end
    end
end

function playerService:remove(character)
    local data = self.cache[character]
    if not data then return end

    for _, draw in pairs(data.drawings) do
        draw:Remove()
    end
    self.cache[character] = nil
end

function playerService:new(player)
    local function cache(char)
        self.cache[char] = {
            player = player,
            drawings = {
                box = services.new.drawing("Square", {Visible=false}),
                name = services.new.drawing("Text", {Visible=false, Center=true}),
                health = services.new.drawing("Line", {Visible=false}),
                tracer = services.new.drawing("Line", {Visible=false}),
                tracerOutline = services.new.drawing("Line", {Visible=false}),
            }
        }
    end

    local function init(char)
        if self:check(char) then
            cache(char)
        else
            char.ChildAdded:Connect(function()
                if self:check(char) then cache(char) end
            end)
        end
    end

    if player.Character then init(player.Character) end
    player.CharacterAdded:Connect(init)
end

function playerService:update(character, data)
    if not self:check(character) then return self:remove(character) end

    local root = character:FindFirstChild("HumanoidRootPart")
    local player = data.player
    local drawings = data.drawings
    local cameraPos = camera.CFrame.Position
    local dist = (cameraPos - root.Position).Magnitude
    local screenPos, visible = camera:WorldToViewportPoint(root.Position)

    if not (features.visuals.enabled and visible and dist <= features.visuals.renderDistance) then
        for _, d in pairs(drawings) do d.Visible = false end
        return
    end

    local teamOk = not features.visuals.teamCheck or player.Team ~= client.Team
    if not teamOk then for _, d in pairs(drawings) do d.Visible = false end return end

    local function applyDraw(draw, props)
        for k, v in pairs(props) do
            if draw[k] ~= v then draw[k] = v end
        end
        draw.Visible = true
    end

    local scale = 1 / (screenPos.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
    local w, h = 4.5 * scale, 6 * scale
    local x, y = screenPos.X, screenPos.Y
    local xPos, yPos = x - w/2, y - h/2 + 0.5 * scale

    -- Box
    applyDraw(drawings.box, {
        Position = Vector2.new(xPos, yPos),
        Size = Vector2.new(w, h),
        Color = features.visuals.boxes.color,
        Thickness = 1,
        ZIndex = 0
    })

    -- Name
    applyDraw(drawings.name, {
        Text = `[ {player.Name} ]`,
        Size = math.clamp(12.5 * scale, 10, 12.5),
        Position = Vector2.new(x, yPos - 15),
        Color = features.visuals.names.color,
        Outline = features.visuals.names.outline.enabled,
        OutlineColor = features.visuals.names.outline.color,
        ZIndex = 1
    })

    -- Tracer
    local startY = camera.ViewportSize.Y
    local startX = camera.ViewportSize.X / 2
    local startVec = Vector2.new(startX, startY)
    local toVec = Vector2.new(x, y)

    applyDraw(drawings.tracerOutline, {
        From = startVec,
        To = toVec,
        Color = features.visuals.tracer.outline.color,
        Thickness = 3,
        ZIndex = -1
    })

    applyDraw(drawings.tracer, {
        From = startVec,
        To = toVec,
        Color = features.visuals.tracer.color,
        Thickness = 1,
        ZIndex = 0
    })

    -- Health
    local hp = character:FindFirstChild("Humanoid")
    if hp then
        local healthPct = math.clamp(hp.Health / hp.MaxHealth, 0, 1)
        local hpColor = features.visuals.health.colorLow:Lerp(features.visuals.health.color, healthPct)
        applyDraw(drawings.health, {
            From = Vector2.new(xPos - 5, yPos + h),
            To = Vector2.new(xPos - 5, yPos + h - (h * healthPct)),
            Color = hpColor,
            Thickness = 2
        })
    end
end

services.loop:new("playerLoop", function()
    for char, data in pairs(playerService.cache) do
        playerService:update(char, data)
    end
end)

-- Expose features table
declare(global, "features", {})

features.toggle = function(self, k, state)
    local f = self[k]
    if f then
        f.enabled = (state == nil) and not f.enabled or state
        if f.toggle then task.spawn(f.toggle, f) end
    end
end
