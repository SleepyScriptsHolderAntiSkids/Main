-- esp [wip]

local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        for _, method in {"remove", "Disconnect"} do
            pcall(function()
                value[method](value)
            end)
        end
    end
    return self[index]
end

declare(global, "services", {})
function global.get(service)
    return services[service]
end

declare(declare(services, "loop", {}), "cache", {})

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled, func = func, index
    end
    local entry = self.cache[index] or {
        enabled = not disabled,
        func = func,
        toggle = function(s, b)
            s.enabled = b == nil and not s.enabled or b
        end,
        remove = function()
            self.cache[index] = nil
        end
    }
    self.cache[index] = entry
    entry.enabled = not disabled
    entry.func = func

    if entry.enabled then
        task.defer(function()
            if entry.func then entry.func() end
        end)
    end
    return entry
end

local runService = cloneref(game:GetService("RunService"))
declare(get("loop"), "connection", runService.RenderStepped:Connect(function(delta)
    for _, loop in get("loop").cache do
        if loop.enabled then
            pcall(function()
                loop.func(delta)
            end)
        end
    end
end), true)

declare(services, "new", {})
get("new").drawing = function(class, props)
    local d = Drawing.new(class)
    for k, v in props do
        pcall(function()
            d[k] = v
        end)
    end
    return d
end

declare(declare(services, "player", {}), "cache", {})

local drawingTemplate = {
    {"box", "Square"}, {"boxFilled", "Square", {Filled = true}}, {"boxOutline", "Square"},
    {"name", "Text", {Center = true}}, {"health", "Line"}, {"healthOutline", "Line"},
    {"healthText", "Text"}, {"distance", "Text", {Center = true}}, {"weapon", "Text", {Center = true}},
    {"tracer", "Line"}, {"tracerOutline", "Line"}
}

for _, corner in {"TL", "TR", "BL", "BR"} do
    for _, dir in {"H", "V"} do
        table.insert(drawingTemplate, {"corner" .. corner .. dir, "Line"})
        table.insert(drawingTemplate, {"corner" .. corner .. dir .. "Outline", "Line"})
    end
    table.insert(drawingTemplate, {"cornerFilled" .. corner, "Square", {Filled = true}})
end

get("player").find = function(self, player)
    for c, d in self.cache do
        if d.player == player then return c end
    end
end

get("player").check = function(_, player)
    local ok, valid = pcall(function()
        local char = player:IsA("Player") and player.Character or player
        return char and char.Parent and char:FindFirstChild("Humanoid") and char:FindFirstChild("HumanoidRootPart")
    end)
    return ok and valid
end

get("player").new = function(self, player)
    local function cache(char)
        local d = {}
        for _, def in drawingTemplate do
            local name, class, opts = def[1], def[2], def[3] or {Visible = false}
            d[name] = get("new").drawing(class, opts)
        end
        self.cache[char] = {player = player, drawings = d}
    end
    local function validate(char)
        if self:check(char) then
            cache(char)
        else
            char.ChildAdded:Connect(function()
                if self:check(char) then cache(char) end
            end)
        end
    end
    if player.Character then validate(player.Character) end
    player.CharacterAdded:Connect(validate)
end

get("player").remove = function(self, player)
    local char = player:IsA("Player") and self:find(player) or player
    local d = self.cache[char] and self.cache[char].drawings
    self.cache[char] = nil
    if d then
        for _, v in d do v:Remove() end
    end
end

-- ðŸ©¹ Stub to prevent error (WIP area)
get("player").update = function(self, char, data)
    -- no-op placeholder to avoid runtime error
end

get("loop"):new("playerLoop", function()
    for char, data in get("player").cache do
        get("player"):update(char, data)
    end
end)

declare(global, "features", {})
features.toggle = function(self, feat, val)
    local f = self[feat]
    if f then
        f.enabled = val == nil and not f.enabled or val
        if f.toggle then
            task.spawn(function()
                f:toggle()
            end)
        end
    end
end

for _, p in players:GetPlayers() do
    if p ~= client and not get("player"):find(p) then
        get("player"):new(p)
    end
end

declare(get("player"), "added", players.PlayerAdded:Connect(function(p)
    get("player"):new(p)
end), true)

declare(get("player"), "removing", players.PlayerRemoving:Connect(function(p)
    get("player"):remove(p)
end), true)
