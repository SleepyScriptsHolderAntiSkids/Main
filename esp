-- Services & Local Variables
local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local runService = cloneref(game:GetService("RunService"))

getgenv().global = getgenv()

-- Global Declaration Utility
function global.declare(self, index, value, check)
	if self[index] == nil then
		self[index] = value
	elseif check then
		local methods = { "remove", "Disconnect" }
		for _, method in methods do
			pcall(function() value[method](value) end)
		end
	end
	return self[index]
end

-- Services Initialization
declare(global, "services", {})
function global.get(service) return services[service] end
declare(declare(services, "loop", {}), "cache", {})

-- Loop Management
get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func
        func = index
    end

    local entry = self.cache[index]
    if not entry then
        entry = {
            enabled = not disabled,
            func = func,
            toggle = function(self, bool)
                self.enabled = bool == nil and not self.enabled or bool
            end,
            remove = function()
                self.cache[index] = nil
            end
        }
        self.cache[index] = entry
    else
        entry.enabled = not disabled
        entry.func = func
    end

    if entry.enabled and entry.func then
        task.defer(entry.func)
    end

    return entry
end

-- RenderStep Loop
declare(get("loop"), "connection", runService.RenderStepped:Connect(function(delta)
	for _, loop in get("loop").cache do
		if loop.enabled then
			local success, result = pcall(function()
				loop.func(delta)
			end)
		end
	end
end), true)

-- Drawing Object Factory
declare(services, "new", {})
get("new").drawing = function(class, properties)
	local drawing = Drawing.new(class)
	for prop, val in properties do
		pcall(function() drawing[prop] = val end)
	end
	return drawing
end

-- Player Handling
declare(declare(services, "player", {}), "cache", {})

get("player").find = function(self, player)
	for character, data in self.cache do
		if data.player == player then return character end
	end
end

get("player").check = function(self, player)
	local success, check = pcall(function()
		local character = player:IsA("Player") and player.Character or player
		local children = { character.Humanoid, character.HumanoidRootPart }
		return children and character.Parent ~= nil
	end)
	return success and check
end

get("player").new = function(self, player)
	local function cache(character)
		self.cache[character] = {
			player = player,
			drawings = {} -- will be filled below
		}
		local d = self.cache[character].drawings
		local names = {
			"box", "boxFilled", "boxOutline", "name", "health", "healthOutline",
			"healthText", "distance", "weapon", "tracer", "tracerOutline",
			"cornerTLH", "cornerTLV", "cornerTRH", "cornerTRV",
			"cornerBLH", "cornerBLV", "cornerBRH", "cornerBRV",
			"cornerTLHOutline", "cornerTLVOutline", "cornerTRHOutline", "cornerTRVOutline",
			"cornerBLHOutline", "cornerBLVOutline", "cornerBRHOutline", "cornerBRVOutline",
			"cornerFilledTL", "cornerFilledTR", "cornerFilledBL", "cornerFilledBR"
		}
		for _, name in names do
			local class = name:match("Text") and "Text" or name:match("box") or name:match("Filled") and "Square" or "Line"
			local props = { Visible = false }
			if class == "Square" and name:find("Filled") then props.Filled = true end
			if class == "Text" then props.Center = true end
			d[name] = get("new").drawing(class, props)
		end
	end

	local function check(character)
		if self:check(character) then
			cache(character)
		else
			local listener; listener = character.ChildAdded:Connect(function()
				if self:check(character) then
					cache(character)
					listener:Disconnect()
				end
			end)
		end
	end

	if player.Character then check(player.Character) end
	player.CharacterAdded:Connect(check)
end

-- Player Removal
get("player").remove = function(self, player)
	if player:IsA("Player") then
		local character = self:find(player)
		if character then self:remove(character) end
	else
		local drawings = self.cache[player].drawings
		self.cache[player] = nil
		for _, drawing in drawings do
			drawing:Remove()
		end
	end
end

-- Visual Update (shortened here for brevity; same as yours)
-- You already posted a well-written update function. If you'd like I can reformat/optimize it.

-- Loop over all characters
declare(get("player"), "loop", get("loop"):new(function()
	for character, data in get("player").cache do
		get("player"):update(character, data)
	end
end), true)

-- Features Declaration
declare(global, "features", {})
features.toggle = function(self, feature, boolean)
	if self[feature] then
		self[feature].enabled = boolean == nil and not self[feature].enabled or boolean
		if self[feature].toggle then task.spawn(function() self[feature]:toggle() end) end
	end
end

-- Visuals Feature
declare(features, "visuals", {
	enabled = false,
	teamCheck = false,
	teamColor = true,
	renderDistance = 2000,
	boxes = {
		enabled = true,
		style = "Box",
		color = Color3.fromRGB(255, 255, 255),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0),
		},
		filled = {
			enabled = true,
			color = Color3.fromRGB(255, 255, 255),
			transparency = 0.25
		},
	},
	names = {
		enabled = true,
		color = Color3.fromRGB(255, 255, 255),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0),
		},
	},
	health = {
		enabled = true,
		color = Color3.fromRGB(0, 255, 0),
		colorLow = Color3.fromRGB(255, 0, 0),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0)
		},
		text = {
			enabled = true,
			outline = {
				enabled = true,
			},
		}
	},
	distance = {
		enabled = true,
		color = Color3.fromRGB(255, 255, 255),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0),
		},
	},
	weapon = {
		enabled = true,
		color = Color3.fromRGB(255, 255, 255),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0),
		},
	},
	tracer = {
		enabled = false,
		startPosition = "bottom",
		color = Color3.fromRGB(255, 255, 255),
		outline = {
			enabled = true,
			color = Color3.fromRGB(0, 0, 0),
		},
	}
})

-- Player Events
for _, player in players:GetPlayers() do
	if player ~= client and not get("player"):find(player) then
		get("player"):new(player)
	end
end

declare(get("player"), "added", players.PlayerAdded:Connect(function(player)
	get("player"):new(player)
end), true)

declare(get("player"), "removing", players.PlayerRemoving:Connect(function(player)
	get("player"):remove(player)
end), true)
